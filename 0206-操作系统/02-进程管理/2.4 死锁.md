# 死锁


**死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。


## 死锁、饥饿、死循环的对比

- **死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象
	- 至少有两个或两个以上的进程同时发生死锁
	- 是管理者（操作系统）的问题
- **饥饿**：由于长期得不到想要的资源，某进程无法向前推进的现象
	- 可能只有一个进程发生饥饿
	- 是管理者（操作系统）的问题
- **死循环**：某进程执行过程中一直跳不出某个循环的现象
	- 可能只有一个进程发生死循环
	- 死循环是被管理者的问题
	- 死循环的进程可以上处理机运行

## 死锁产生的条件

- **互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁
	- 不用阻塞等待的资源不会导致死锁
- **不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
- **请求和保持条件**：进程*已经保持了至少一个资源*，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
- **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。


>[!attention]+  注意：循环等待是死锁的必要不充分条件
>- 发生死锁时一定有循环等待
>- 但是发生循环等待时未必死锁

## 发生死锁的原因

- **对系统资源的竞争**：各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的
- **进程推进顺序非法**：请求和释放资源的顺序不当，也同样会导致死锁
	- 如并发执行的进程P1、P2分别申请，并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁
- **信号量的使用不当也会造成死锁**：如生产者—消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁

>[!tip]+  提示：可以把互斥信号量、同步信号量也看做是一种抽象的系统资源

## 死锁的处理策略

### 预防死锁

**预防死锁**：破坏死锁产生的四个必要条件中的一个或几个
- 不允许死锁发生
	- 静态策略：预防死锁，破坏[#死锁产生的条件](.md#死锁产生的条件)
	- 动态策略：避免死锁
- 允许死锁发生：死锁的检测和解除

#### 破坏互斥条件

**破坏互斥条件**：把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态
- SPOOLing技术
- **该策略的缺点**：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件

#### 破坏不剥夺条件

**破坏不剥夺条件**
- 方案一：当进程请求新的资源得不到满足时，必须立即释放保持的所有资源，待以后需要时再重新申请
	- 即使某些资源尚未使用完，也需要主动释放
- 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺
	- 这种方式一般需要考虑各进程的优先级
	- 剥夺调度方式：就是将处理机资源强行剥夺给优先级更高的进程使用
- 该策略的缺点
	- *实现起来比较复杂*
	- *释放资源会造成前阶段工作失效*：一般只适用于易保存和恢复状态的资源，如CPU


#### 破坏请求和保持条件

**可以采用静态分配方法**：在运行前一次申请完所需要的全部资源，在资源未满足前，不让它投入运行。运行后，进程不会再请求别的资源
- 资源利用率极低：有些资源可能只需要用很短的时间，进程会在整个运行期间都一直保持着所有资源
- 可能导致进程饥饿

#### 破坏循环等待条件

**可采用顺序资源分配法**：首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完
- *原理分析*：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。已持有大编号资源的进程不能逆向地申请小编号的资源，从而就不会产生循环等待的现象
- 该策略的缺点：
	- *不方便增加新的设备*：可能需要重新分配所有的编号
	- *会导致资源浪费*：进程实际使用资源的顺序可能和编号递增顺序不一致

### 避免死锁

**避免死锁**：用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)
- **安选序列**：能使每个进程都顺利完成资源分配的序列
- **安全状态**：至少存在一个安全序列
	- *不安全状态*：不存在任何一个安全序列
- *安全状态*和*死锁*的关系
	- 如果系统处于*安全状态*，就*一定不会*发生死锁
	- 如果系统进入*不安全状态*，就*可能*发生死锁
	- 处于不安全状态，未必就是发生了死锁
	- 但是发生死锁时，一定是在不安全状态

#### 银行家算法

**银行家算法核心思想**：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待

- 假设系统中有$n$个进程,$m$种资源
- 每个进程在运行前，先声明对各资源的最大需求数
- 算法需要的参数
	- *最大需求矩阵*($\mathrm{Max}$)：$n\times m$的矩阵，表示所有线程对各种资源的最大需求数
	- *分配矩阵*($\mathrm{Allocation}$)：$n\times m$的矩阵，表示对所有进程的资源分配情况
	- *需求矩阵*($\mathrm{Need}=\mathrm{Max}-\mathrm{Allocation}$)：$n\times m$的矩阵，表示各个进程最多还需要多少各类资源
	- *可用序列*($\mathrm{Available}$)：长度为$m$的一维数组，表示当前系统中还有多少可用资源
	- *申请序列*($\mathrm{Request}_{i}$)：程度为$m$的一维数组，表示某进程$Pi$向系统申请资源
- 则$Max[i,j]=K$表示进程$Pi$最多需要$K$个资源$Rj$


##### 银行家算法举例
- $\mathrm{Available}=(3,3,2)$

| $Pi$    | $\mathrm{Max}$ | $\mathrm{Allocation}$ | $\mathrm{Need}$ |
| ------- | -------------- | --------------------- | --------------- |
| $P_{0}$ | $(7,5,3)$      | $(0,1,0)$               | $(7,4,3)$             |
| $P_{1}$ | $(3,2,2)$      | $(2,0,0)$               | $(1,2,2)$             |
| $P_{2}$ | $(9,0,2)$       | $(3,0,2)$                   | $(6,0,0)$             |
| $P_{3}$ | $(2,2,2)$      | $(2,1,1)$                   | $(0,1,1)$             |
| $P_{4}$ | $(4,3,3)$        | $(0,0,2)$                   | $(4,3,1)$             |

- 满足$\mathrm{Request_{i}}[j]\leq\mathrm{Need}[i,j],(0\leq j\leq m)$
	- 否则出错
- 满足$\mathrm{Request}_{i}[j]\leq\mathrm{Available}[j],(0\leq j\leq m)$
	- 否则表示尚无足够资源，$P_{i}$等待
- 预分配资源给$Pi$
	- $\mathrm{Available}=\mathrm{Available}-\mathrm{Request}$
	- $\mathrm{Allocation}[i,j]=\mathrm{Allocation}[i,j]+\mathrm{Request}_{i}[j]$
	- $\mathrm{Need}[i,j]=\mathrm{Need}[i,j]-\mathrm{Request}_{i}[j]$
- 执行安全性算法：检查分配资源后，系统是否处于安全状态
	- 如果安全，则分配资源
	- 如果不安全，则撤回预分配资源，并阻塞进程
### 死锁的检测和解除

**死锁的检测和解除**：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁


#### 死锁的检测
- 用某种数据结构保存资源的请求和分配信息，例如*资源分配图*
- 提供一种算法，利用上述信息来检测系统是否已经进入死锁状态

##### 资源分配图

资源分配图：保存资源的请求和分配信息
- 进程节点：对应一个进程
- 资源节点：对应一类资源，一类资源可能有多个
- 进程-资源边：表示进程想申请几个资源，每条边代表一个
- 资源-进程边：表示已经为进程分配了几个资源，每条边代表一个

##### 过程分析

- 如果系统中剩余的可用资源数足够满足进程的需求
	- 那么这个进程暂时是不会阻塞的
	- 可以顺利地执行下去
- 如果这个进程执行结束了把资源归还系统
	- 就可能使某些正在等待资源的进程被激活
	- 并顺利地执行下去
- 相应的，这些被激活的进程执行完了之后又会归还一些资源
	- 这样可能又会激活另外一些阻塞的进程..
- 如果按上述过程分析，最终*能消除所有边*，就称这个图是**可完全简化**的
	- 此时一定*没有发生死锁*（相当于能找到一个安全序列)
- 如果最终*不能消除所有的边*，那么此时*发生了死锁*
	- 还连着边的那些进程就是处于死锁状态的进程

- 在资源分配图中，找出既不阻塞又不是孤点的进程Pi
	- 即找出一条有向边与它相连
	- 且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量
	- 若所有的连接该进程的边均满足上述条件
		- 则这个进程能继续运行直至完成
		- 然后释放它所占有的所有资源
- 消去它所有的请求边和分配变
	- 使之称为孤立的结点
- 进程Pi所释放的资源可以唤醒某些因等待这些资源而阻塞的进程
	- 原来的阻塞进程可能变为非阻塞进程，进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的

#### 死锁的解除
1.资源剥夺法。

2.撤销进程法（或称终止进程法）。

3.进程回退法。
##### 资源剥夺法

**资源剥夺法**：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程
- 但是应防止被挂起的进程长时间得不到资源而饥饿

##### 撤销进程法

**撤销进程法**(终止进程)：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源
- 实现简单
- 代价可能会很大：因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止还需要从头再来

##### 进程回退法

**进程回退法**：让一个或多个死锁进程回退到足以避免死锁的地步
- 这就要求系统要记录进程的历史信息，设置还原点

##### 牺牲进程的决定依据

- 进程优先级
- 进程的已执行时间
- 进程的剩余时间
- 进程所用的资源
- 进程是交互式的还是批处理式的


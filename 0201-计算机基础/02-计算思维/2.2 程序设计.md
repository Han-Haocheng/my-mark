---
tags:
  - 计算机/程序设计
  - 笔记层次/3
---


# 程序设计

## 程序和算法
### 程序
程序：完成任何事情都需要有个先后次序，这些按一定的顺序安排的工作即操作序列。用来描述计算机处理数据、解决问题的过程。
- 著名的计算机科学家沃思曾提出：程序＝数据结构＋算法
- 算法是程序的核心

### 算法

算法：解题方案的准确而完整的描述，解决问题的方法和步骤，解决问题的思路。
- *算法可解*：对于一个问题，可以通过一个计算机程序，在有限的存储空间内运行有限长的时间而得到正确的结果
- 算法不等于程序，不等于计算方法。
- 程序可以作为算法的一种描述，程序通常还需考虑很多与方法和分析无关的细节问题，因为在编写程序时要受到计算机系统运行环境的限制
- 程序的编制不可能优于算法的设计


>[!faq]+ 例题1．关于算法和程序，下列叙述正确的是（D) （单选）
> - A．程序由算法决定，与数据结构无关
> - B．算法一定是深奥的，包含了复杂的数学知识
> - C．同一个算法对应的程序是唯一的
> - D．算法是指问题求解的方法及求解过程的描述，程序是算法的具体实现

### 算法的基本特征
- 可行性：每一步都能够通过执行有限的次数完成
- 确定性：每一个步骤都具有确定的含义，不能出现二义性
- 有穷性：执行有穷个计算步骤后必须终止
- 输入（Input)：一个算法有0个或多个输入
- 输出（Output)：一个算法有一个或多个输出


### 算法的表示方法

自然语言、流程图、N-S图、伪代码和计算机语言等。

#### 自然语言
自然语言：指人们在日常生活中使用的语言，用自然语言描述的算法通俗易懂，但缺乏直观性和简洁性，容易产生歧义

>[!example]+ 举例：以求解$sum=1+2+\dots+(n-1)+n$为例，使用自然语言描述从$1$开始的连续$n$个自然数求和的算法
> 1. 确定一个$n$的值
> 2. 假设等号右边的算式项中的初始值$i$为$1$
> 3. 假设$sum$ 的初始值为$0$
> 4. 如果$i\leq n$时，执行5，否则转出执行6
> 5. 计算$sum$ 加上$i$ 的值后，重新赋值给 $sum$
> 6. 计算$i$加$1$，然后将值重新赋值给$i$



#### 流程图
**流程图**：是算法的一种图形化表示方法，与自然语言相比，描述形象直观更容易理解

|   符号   |  名称   |              功能               |
| :----: | :---: | :---------------------------: |
|  圆形框   |  起止框  |          表示算法的开始和结束           |
|  矩形框   | 输入输出框 |          表示算法的输入输出信息          |
| 圆角矩形框  |  处理框  |     表示算法需要处理的内容，只有一个入口和出口     |
| 平行四边形框 |  判断框  | 表示算法中的条件判断，4个顶点中一个代表入口，其余表示出口 |
|  流程线   |  流程线  |           表示算法的执行方向           |
|  连接点   |  连接点  |           表示流程图的延续            |

> [!faq]- 老师班级里有45个学生，某次语文考试成绩存放在S中，$S[i]$表示第$i$个学生的成绩$(i=1,2,3,..,45)$，为了编制计算机程序统计不及格（成绩小于60）的学生人数（用C表示），刘老师画了流程图，如下图所示，请结合所学知识回答以下问题。</br>1. 下图中①处应填入 $i<=45?$</br>2. 图中$C=C+1$的作用是 累计计算不及格人数</br>![](attachment/svg/20241127114618.svg)


#### NS图

N-S图：它是一种简化的流程图，去掉了流程图中的流程线，全部算法写在一个矩形框内

![](attachment/svg/20241127112108.svg)

#### 伪代码

伪代码：介于自然语言和计算机语言之间的一种算法描述，没有严格的语法限制。是一种用来书写程序或描述算法时使用的非正式、透明的表述方法。不是编程语言，这种方法针对的是一台虚拟的计算机

```C
//使用伪代码描述从1开始的连续n个自然数求和的算算
begin //算法开始
Input n //输入 n 的值
i-1 //＊为变量i 赋初值＊/
sum-0 //* 为变量 sum 赋初值＊/
do while i<=n /*当变量 i <=n时，执行下面的循环体语句*/

sum-sum+i //等价于sum=sum+i
i-i+1    //等价于i=i+1
```

#### 计算机语言

计算机语言：计算机无法识别自然语言、流程图、N-S图、伪代码。这些方法仅为了帮助人们描述、理解算法，要用计算机解题，就要用计算机语言描述算法。只有用计算机语言编写的程序才能被计算机执行（需要被编译成目标程序）

```C
// 用C语言来1+2的加法问题
int a=1,b=2,c=a+b;
print("%d",c);
```

>[!faq]+ 例题1．下列有关算法和程序的关系，说法正确的是（B)（单选）</br>A. 算法与程序是一一对应的</br>B. 程序是算法的具体实现</br>C. 算法必须使用程序设计语言进行描述 </br>D. 算法是程序的简化

>[!faq]+ 例题2．用计算机进行解题，就要用（A）描述算法。（单选）</br>A. 计算机语言 B. 自然语言 C. 流程图 D.伪代码

## 算法的控制结构

 算法的基本要素
- 对数据对象的运算和操作
- 算法的控制结构

### 算法的控制结构
算法的控制结构：算法中各操作之间的执行顺序
- 算法的基本控制结构：顺序、选择、循环
- 算法定会使用顺序结构

### 顺序结构
顺序结构：按语句出现的先后顺序执行的程序结构，是结构化程序中最简单的结构。

### 选择结构

选择结构(分支结构)：当程序执行到控制分支的语句时，首先判断条件，根据条件表达式的值选择相应的语句执行，放弃另一部分语句的执行
- 分支结构的形式：单分支、双分支和多分支

### 循环结构
循环结构(重复结构)：根据给定的条件，判断是否需要重复执行相同的或类似的程序段，利用重复结构可简化大量的程序行
- 当型循环结构：对先判断后执行循环体
- 直到型循环结构：对先执行循环体后判断。条件不满足时执行循环体，满足时则停止，循环体至少执行一次

## 算法分析

[[0205-数据结构与算法/01-绪论/1.4 算法和算法分析]]

- 算法分析的目的：选择合适算法
- 算法的复杂性：是算法效率的度量，是评价算法优劣的重要依据
- 算法的效率：与数据的逻辑结构、存储结构、问题规模、初始输入的数据等密切相关

- 评价算法的重要标准
	- 时间复杂度
	- 空间复杂度
	- 正确性：输入一个数能得到正确结果
	- 可读性：算法清晰容易理解
	- 健壮性：输入非法数据，算法能进行相应处理，处理错误不中断程序的执行，返回到高层处理

### 算法复杂度

- 算法复杂度：包含算法时间复杂度和算法空间复杂度

### 渐进表示法

渐进表示法：忽略所有低次幂项和最高次幂项的系数
- 常见算法复杂度由小到大：$O (1) <O (\log_2n) <O (n) <O (n\log_2n) <O (n^{2}) <O (n^{3}) ..…<O (2^{n}) <O(n!)$
- 尽量选用多项式阶$O(n^{k})$

### 算法时间复杂度

算法时间复杂度：是指执行算法所需要的计算工作量（基本运算次数），通常使用事前统计法
- 事前分析法：估算语句执行的次数
- 语句频度(时间频度)：一个算法中的语句执行次数。在时间频度不相同时，时间复杂度有可能相同。
	- 如$T(n)=n^{2}+3n+4$与$T(n)=4n^{2}+2n+1$

### 算法空间复杂度

算法空间复杂度：是指执行这个算法所需要的内存空间。
- 一个算法所占的存储空间包括3部分：
	- 算法程序所占的空间
	- 输入的初始数据所占的存储空间
	- 算法执行过程中所需要的额外空间
- 减少算法所占的存储空间：通常采用压缩存储技术


>[!tip]+ 提示：虽然时间复杂度和空间复杂度之间没有必然联系，但大致上它们是矛盾的

>[!faq]+ 例题1．算法的时间复杂度是指（C)（单选）</br>A．设计该算法所需的工作量</br>B．执行该算法所需要的时间</br>C．执行该算法时所需要的基本运算次数 </br>D．算法中指令的条数

>[!faq]+ 例题2．下列叙述中正确的是（D)（单选）</br>A．算法就是程序</br>B．设计算法时只需要考虑数据结构的设计</br>C．设计算法时只需要考虑结果的可靠性 </br>D．以上三种说法都不对

>[!faq]+ 例题3．下列叙述中正确的是（D)（单选）</br>A．一个算法的空间复杂度大，则其时间复杂度也必定大</br>B．一个算法的空间复杂度大，则其时间复杂度必定小</br>C．一个算法的时间复杂度大，则其空间可复杂度必定小</br>D．上述三种说法都不对

### 算法的基本设计方法

#### 穷举法
穷举法(枚举法)：即将可能出现的每一种情况一一测试，判断是否满足条件，一般采用环来实现

#### 贪心法

贪心法(贪婪法)：不追求最优解，只希望得到较为满意的解法，不考虑各种可能的整体情况，只以当前情况为基础做最优设计

#### 分治法

分治法：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破。

#### 迭代法

迭代法(递推法)：利用问题本身具有的某种递推关系求解问题的一种方法
- 如：求阶乘n!

#### 递归法

递归法：在解决复杂问题的时候，为了降低问题的复杂度，一般总是将问题逐层分解，最后归结为一些最简单的问题。最后解决了哪些简单的问题后，再沿着原来分解的逆过程逐步进行综合。

>[!faq]+ 例题1．密码破解时，通过连接产生不重复的候选密码，然后逐一对其进行正确性试探，此算法是（A)</br>A．穷举法 B．迭代法 C．递归法 D．回溯法

## 常用查找与排序算法

### 查找
查找：获取一个数在数组中的位置

#### 顺序查找

顺序查找：对数据的排列先后次序没有任何要求，时间复杂度$O(n)$

#### 折半查找
折半查找(二分法查找)：只适用于顺序存储的有序表
- 使用二分法在已排序的数组$a[h]$中查找某个指定数值时，最多需要$r=log_2n$ 次，若r不是整数，那么$r=int(r)+1$

- 设有序线性表的长度为n，被查找的元素为i,
	1. 将i与线性表的中间项进行比较；
	2. 若i与中间项的值相等，则查找成功；
	3. 若i小于中间项，则在线性表的前半部分以相同的方法查找；
	4. 若i大于中间项，则在线性表的后半部分以相同的方法查找。

```C++

int func(int *nums,int size, int target){{ 
	int left = 0; 
	int right = size - 1; // 定义了target在左闭右闭的区间内，[left, right] 
	while (left <= right) { //当left == right时，区间[left, right]仍然有效 
		int middle = left + ((right - left) / 2);//等同于 (left + right)/2，防止溢出 
		if (nums[middle] > target) { 
			right = middle - 1; //target在左区间，所以[left, middle - 1] 
		} else if (nums[middle] < target) { 
			left = middle + 1; //target在右区间，所以[middle + 1, right] 
		} else { //既不在左边，也不在右边，那就是找到答案了 
		return middle; 
		} 
	} 
	//没有找到目标值 
	return -1; 
}

```


>[!faq]+ 例题1．在已排序的数据中，用于实现快速查找的算法是（C)</br>A．冒泡法 B．枚举法 C．二分法 D．迭代法

>[!faq]+ 例题2.1000个已排序的数，若用二分法最多几次可以查找到指定的数值（B)</br>A.5 B.10 C.15 D.20

### 排序

#### 冒泡排序

冒泡排序：每次比较两个相邻的元素的大小，如果顺序不对的那么交换位置

```C
void bubble_sort(int*arr,int len){
	//定义一个标志位，用于判定元素之间是否进行了交换
	bool flag = false;
	for (int i = 0,i_ed = len - 1; i < ; i++) { 
		for (int j = 0,j_ed=i_ed-i; j < j_ed; j++) {
			if (arr[j] > arr[j + 1]) {
				//进入这个if分支里边，则说明有元素进行了交换
				//所以将flag=true
				flag = true;
				swap(arr[j], arr[j + 1])
			}
		}
		//在进行完一轮的排序之后，判断本轮是否发生了元素之间的交换
		//如果没有发生交换，说明数组已经是有序的了，则直接结束排序
		if (!flag) {
			break;
		} else {
			//如果发生了交换，那么在下一轮排序之前将flag再次置为false
			//以便记录下一轮排序的时候是否会发生交换
			flag = false; 
		}
	}
}
```

#### 选择排序

选择排序：每次从当前排序的序列中选择最值元素，然后与待排序的元素的序列中的第一个元素进行交换，直到整个数组有序为止。
```c
void selection_sort(int arr[], int len) {
    int i,j;
    for (i = 0 ; i < len - 1 ; i++) {
		int min = i;
		for (j = i + 1; j < len; j++)     //走訪未排序的元素
			if (arr[j] < arr[min])    //找到目前最小值
				min = j;     //紀錄最小值
		swap(&arr[min], &arr[i]);    //做交換
    }
}
```

## 数据结构

数据结构：反应数据元素之间关系的数据元素集合的表示
- 数据结构研究的三个方面：
	- 数据集合中各数据元素之间所固有的逻辑关系，即数据的逻辑结构；
	- 在对数据进行处理时，各数据元素在计算机中的存储关系，即数据的存储结构；
	- 对各种数据结构进行的运算。
- 数据结构学科的研究目的：提高数据处理的效率


### 数据结构的逻辑结构

数据的逻辑结构：表示数据元素的信息；表示各数据元素之间的前后件关系
- 典型的数据结构（逻辑结构）包括线性表、堆栈和队列
#### 线性结构：

线性结构：有且只有一个根结点；每一个结点最多有一个前件，也最多有一个后件。

#### 非线性结构

非线性结构：不满足线性结构条件的数据结构

### 栈

栈：是限定在一端进行插入与删除的线性表
- 栈顶：允许插入与删除的一端
- 栈底：不允许插入与删除的另一端
- 栈按照"先进后出"(FILO）或"后进先出"(LIFO）组织数据，站具有记忆作用

### 队列
队列：是指允许在一端（队尾）进入插入，而在另一端（队头）进行删除的线性表。Rear指针指向队尾，front指针指向队头元素前一个位置
- 队列是"先进行出"(FIFO）或"后进后出"(LILO）的线性表


### 树

树：非线性结构，一对多关系，一个根节点可以连接多个子节点
- 度：节点子树的最大个数
- 叶子节点：没有子节点的节点
- 树的深度：根节点距离叶子节点最远的距离

#### 二叉树


二叉树：度为二的树，叶子节点总比度为二的节点多一个

#### 树的遍历

- 前序遍历：中->左->右
- 中序遍历：左->中->右
- 后序遍历：左->右->中



### 数据结构的存储结构

数据的存储结构：数据的逻辑结构在计算机存储空间中的存放形式。
- 数据的存储结构的种类：顺序结构、链式结构、索引结构

## 程序设计设计方法和风格
"清晰第一、效率第二"已成为当今主导的程序设计风格。

常用的程序设计方法：结构化程序设计方法、面向对象的程序设计方法

### 结构化程序设计

- 结构化程序设计方法原则
	- 自顶向下
	- 逐步求精：逐步优化，不追求一步到位
	- 模块化：降低程序间的耦合度
	- 限制使用goto语句：不要使用破坏结构完整性的语句
- 结构化程序的基本结构
	- 顺序结构
	- 选择结构
	- 重复结构
- 结构化程序面临的两个问题：
	- 难以适应大型软件的设计
	- 程序可重用性差

### 面向对象方法

面向对象：对象和类是面向对象的核心

- 面向对象方法的优点
	- 与人类习惯的思维方法一致
	- 稳定性好
	- 可重用性好
	- 易开发大型软件产品
	- 可维护性好

#### 类和对象
- 对象：是面向对象方法中最基本的概念，可以用来表示客观世界中的任何实体，对象是物理实体的抽象，也可以是人为的概念。是系统中用来描述客观事物的一个实体，是构成系统的一个基本单位，由一组表示其静态特征的属性和它可执行的一组操作组成
- 属性：描述静态特征
- 方法：描述动态特征
- 类：是指具有共同属性、共同方法的对象的集合。所以类是对象的抽象，对象是对应类的一个实例
- 封装：将对象的属性和方法封装成一个整体，使对象的状态信息隐藏，不允许外部的程序直接访问对象的内部信息
- 继承：是指能够直接获得已有的性质和特征，而不必重复定义他们。继承分单继承和多重继承。单继承指一个类只允许有一个父类，多继承指一个类允许有多个父类
- 多态性：是指同样的消息被不同的对象接受时可导致完全不同的行动现象。
- 消息：是一个实例与另一个实例之间传递的信息。*对象之间的联系是通过消息来传递的*
- 事件：一些能够激活对象功能的动作。如："上课铃响起"、"举手"、"单击鼠标"
- 事件驱动：特定事件的发生将引发对象执行相应的事件过程。简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）

>[!faq]+ 例题1．面向对象的系统中，程序的运行机制是（A)</br>A. 事件驱动 B．顺序执行 C．定时触发 D．自动选择

>[!faq]+ 例题2．在面向对象的系统中，对象之间联系时传递的是（C)</br> A．事件 B．属性 C．消息 D．方法

>[!faq]+ 例题3．在面向对象的程序设计中，描述对象行为的是（D)</br>A．对象名 B．属性 C．状态 D．方法

>[!faq]+ 例题4．将自然数集设为整数类I，则下面属于类I实例的是（A)</br>A.518 B.5.18 C.-518 D.518E-2


## 程序设计步骤
分析问题->确定数学模型->算法设计->编写程序->运行和测试

>[!faq]+ 例题1.程序测试的目的是（C)（单选）</br>A．为被测程序设计正确的测试用例</br>B．发现并改正程序中的错误</br>C．发现程序中的错误</br>D．改正程序中的错误

>[!faq]+ 例题2．程序调试的任务是（B)（单选）</br>A．诊断和改正程序中的错误</br>B．发现并改正程序中的错误</br>C．发现程序中的错误</br>D．设计和运行测试用例

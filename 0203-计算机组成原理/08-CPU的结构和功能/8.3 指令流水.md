# 如何提高机器速度

## 提高访存速度

- 高速芯片
- [Cache](0203-计算机组成原理/04-存储器/4.3%20高速缓冲存储器.md)
- 多体并行：对多个存储体交叉访问

## 提高IO和主机之间的传送速度

- [中断](0203-计算机组成原理/05-输入输出设备/5.5%20程序中断方式.md)
- [DMA](0203-计算机组成原理/05-输入输出设备/5.6%20DMA方式.md)
- [通道](0203-计算机组成原理/05-输入输出设备/5.1%20概述.md#具有通道结构的阶段)
- [IO处理机](0203-计算机组成原理/05-输入输出设备/5.1%20概述.md#具有IO处理机的的阶段)
- 多总线

## 提高运算速度

- 高速芯片
- 改进算法
- [快速进位链](0203-计算机组成原理/06-计算机的运算方法/6.5%20算数逻辑单元.md#快速进位链)

## 提高整机处理能力

- 高速器件
- 改进系统结构，开发系统的并行性

# 系统的并行性

并行性

- 并发：两个或多个以上的事件在*同一时间段*发生
- 同时：两个或两个以上的事件在*同一时刻*发生

并行性的等级

- 过程级（程序、进程）：两个或以上的指令在同时被解析，粗粒度
- 指令级：细粒度
  - 指令之间
  - 指令内部

# 指令流水原理

## 指令的串行执行

![20240304152222.png](../../attachments/png/Pasted%20image%2020240304152222.png)

- 取指令：只会使用取指令部件完成
- 执行指令：只会使用执行指令部件完成

> 总结：总有一个部件是空闲状态

## 指令的二级流水

![20240304152448.png](../../attachments/png/Pasted%20image%2020240304152448.png)

取指和执行阶段时间上完全重叠，执行周期减半，速度提高1倍
> 总结：理想状态下的最优解，现实很难达到

## 影响指令流水效率加倍的因素

- 执行时间大于取指时间

```mermaid
graph LR
取指令-->指令缓冲区--> 执行指令部件
```

- [条件转移](0203-计算机组成原理/07-指令系统/7.2%20操作数类型和操作类型.md#转移)指令对指令流水的影响
：必须等上条指令执行结束，才能确定下条指令的地址，从而造成时间损失

> 可采用分支预测的方法解决

## 指令的六级流水

![20240304155044.png](../../attachments/png/Pasted%20image%2020240304155044.png)

- FI：取指令
- DI：指令译码
- CO：形成操作数地址
- FO：取操作数
- EI：执行
- WO：结果写回，写道给的位置

完成一条指令需要6个时间单位

- 串行执行：54个时间单位
- 六级流水：14个时间单位（理想情况）

# 影响指令流水性能的因素

## 结构相关

不同指令争夺同一功能部件产生资源冲突
![20240304155632.png](../../attachments/png/Pasted%20image%2020240304155632.png)
如上图，会产生很多冲突

解决办法

- 停顿，加入气泡
- 指令存储器和数据存储器分开
- 指令预取技术（适用于访存周期短的情况）

## 数据相关

不同指令因重叠操作，可能改变操作数的读写访问顺序

- 写后读相关（RAW）
```asm
SUB R1,R2,R3 ; (R2)-(R3)->R1
ADD R4,R5,R1 ; (R5)+(R1)->R4
```
- 读后写相关（WAR）
```asm
STA M,R2;(R2)->M存储单元
ADD R2,R4,R5;(R4)+(R5)->R2
```
- 写后写相关（WAW）
```asm
MUL R3,R2,R1;(R2)×(R1)->R3
SUB R3,R4,R5;(R4)-(R5)->R3
```

解决方式
- 后推法：将后续指令延后执行
- 旁路技术（前向通道）：将数据结果转移到下一条指令的输入中

## 控制相关
由转移指令引起
![20240305134958.png](../../attachments/png/Pasted%20image%2020240305134958.png)
假如指令3是转移指令，当第3条指令未完成时，后续指令不清楚是否会发生转移

# 流水线的性能
## 吞吐率
吞吐率：单位时间内流水线所完成指令或输出结果的数量
- 最大吞吐率
- 实际吞吐率

设m段的流水线各段时间为$\Delta t$
- 最大吞吐率为$$T_{pmax}=\frac{1}{\Delta t}$$
- 连续处理n条指令实际吞吐率为
$$T_{p}=\frac{n}{m\cdot \Delta t+(n-1)\cdot\Delta t}$$
  - $m\Delta t$：得到第一条指令的结果所需时间
  - $(n-1)\cdot\Delta t$：后续指令每经过$\Delta t$都会得到一个结果的时间

## 加速比$S_p$
加速比$S_p$：采用流水线的速度与等功能的非流水线的速度之比

设m段的流水线各段时间为$\Delta t$
- 完成n条指令在m段流水线上共需
$$T=m\cdot \Delta t+(n-1)\cdot\Delta t$$
- 完成n条指令在等效的非流水线上共需
$$T'=nm\cdot \Delta t$$
- 则$$S_p=\frac{nm\cdot \Delta t}{m\cdot \Delta t+(n-1)\cdot\Delta t}=\frac{nm}{m+n-1}$$
## 效率
效率：流水线各功能的利用率
> 由于流水线有建立时间和排空时间，因此各个功能段的设备不可能一直处于工作状态

![20240305143029.png](../../attachments/png/Pasted%20image%2020240305143029.png)

$$效率=\frac{流水线各段处于工作时间的时空区}{流水线中各段总的时空图}=\frac{mn\Delta t}{m(m+n-1)\Delta t}$$

# 流水线的多发技术

## 超标量技术
- 每个时钟周期内可并发多条独立指令，配置多个功能部件
- 不能调整指令的执行顺序，通过编译优化技术，把可并行执行的指令搭配起来

![20240305145525.png](../../attachments/png/Pasted%20image%2020240305145525.png)

## 超流水线技术
- 在一个时钟周期内再分段，再一个时钟周期内一个功能部件使用多次
- 不能调整指令的执行顺序，靠编译程序解决优化问题

3段3次，提高原本3倍
![20240305145839.png](../../attachments/png/Pasted%20image%2020240305145839.png)
> 注意：区别于流水线的分段，超流水技术不需要加锁存器，一个时钟周期内的多个流水段之间没有关系

## 超长指令字技术
- 由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达到几百位）
- 采用多个处理部件
![20240305150952.png](../../attachments/png/Pasted%20image%2020240305150952.png)

# 流水线结构

## 指令流水线结构
完成一条指令分6段，每段需要一个时钟周期
- 若流水线不出现断流（不产生冲突），1个时钟周期1个结果
- 不采用流水技术，6个时钟周期一个结果
- 理想情况下速度是不采用流水技术的6倍
![20240305151613.png](../../attachments/png/Pasted%20image%2020240305151613.png)

## 运算流水线
完成*浮点加减*运算可分*对阶*、*尾数求和*、*规格化*三段

![20240305151807.png](../../attachments/png/Pasted%20image%2020240305151807.png)

> 分段原则：每段*操作时间*尽量*一致*
# 算法

![20240516205606.png](../../attachment/png/Pasted%20image%2020240516205606.png)

算法：对特定问题**求解方法和步骤**的一种描述，是**指令**的有限**序列**。其中每个指令表示一个或多个操作。


## 算法的描述

- 自然语言：英语、中文
- 流程图：传统流程图，NS流程图
- 伪代码（类语言）：类C语言
- 程序代码：C语言、java语言

## 算法与程序

- 算法：解决问题的一种方法或一个过程，考虑如何将**输入**转换成**输出**，一个问题可以有**多种算法** 

- 程序：用某种**程序设计语言**对算法的**具体实现**

## 算法的特性

### 有穷性

一个算法必须总是在**执行有穷步**之后结束，且**每一步**都在**有穷时间**内完成

### 确定性

算法中的每一条指令必须有确切的含义，**没有二义性**，在任何条件下，只有唯一的一条执行路径，即***对于相同的输入只能得到相同的输出***

### 可行性

算法是可执行的，算法描述的操作可以通过**已经实现的基本操作执行**有限次来实现

### 输入
一个算法有**0或多个输入**

### 输出
一个算法有**1个或多个输出**


## 算法的设计要求

### 正确性（Correctness)

通常以第3层意义上的正确性作为衡量标准

1. 不含错误语法
2. 几组输入数据，输出正确
3. 典型且带有刁难性输入数据，输出正确
4. 一切合法输入数据，输出正确

### 可读性（Readability）

- 算法应该易于人的理解
- 晦涩难读的算法易于隐藏较多错误而难以调试

### 健壮性（Robustness）

- 输入非法数据，算法能进行相应处理
- 处理错误不中断程序的执行，返回到高层处理

### 高效性（Efficiency）

- 时间要求尽量少
- 空间要求尽量少

# 算法分析

判断算法实际是否可行，并对同一个问题的多种算法进行效率上的比较

时间效率和空间效率有时候是矛盾的

## 算法效率的度量

### 事后统计

事后统计：测算算法实现的时间和空间开销
- 结果依赖多种环境因素
- 花费较多的精力实现算法

### 事前分析

事前分析：对算法所消耗资源的一种估算方法

### 渐进表示法

渐进表示法：若有某个辅助函数$f(n)$，使得$n\to +\infty$时，$\lim_{ n \to\infty }\frac{T(n)}{f(n)}=\mathbb{C}, (\mathbb{C}\neq 0)$，则称$f(n)$是$T(n)$的同数量级函数，记作$T(n)=O(f(n))$

- $O$：order，数量级的符号
- $O(f(n))$：算法的渐进时间复杂度，简称时间复杂度

算法中**基本语句重复执行的次数**是**问题规模n**的某个函数$f(n)$，算法的时间度量记作：$T(n)=O(f(n))$

- **基本语句**：执行次数最多的语句
- **问题规模**：所需处理的数据量

***时间复杂度是由嵌套最深层语句的频度决定***

>[!exmple] 举例：$F(n)=2n^{3}+3n^{2}+2n+1$

解
- 引入辅助函数$n^{3}$
- $\lim_{ n \to \infty } \frac{F(n)}{n^{3}}=2$
- $F(n)=O(n^{3})$

#### *渐进时间复杂度的定理

若$f(n)=a_{m}n^{m}+a_{m-1}n^{m-1}+\dots+a_{1}n+a_{0}$是m次多项式，则$F(n)=O(n^{m})$

#### 渐进复杂度的计算规则

*复杂的算法*，可以*分成几个容易估算的部分*，按照*加法和乘法规则*计算时间复杂度

- 加法规则

$$
\begin{align}
 & T(n) \\
= & T_{1}(n)+T_{2}(n) \\
= & O(f(n))+O(g(n)) \\
= & O(\mathrm{max}(f(n),g(n)))
\end{align}
$$
- 乘法规则

$$
\begin{align}
 & T(n) \\
= & T_{1}(n)\times T_{2}(n) \\
= & O(f(n))\times O(g(n)) \\
= & O(f(n)\times g(n))
\end{align}
$$

## 时间复杂度

某简单操作的运行时间$=$一次简单操作的时间$\times$执行操作次数

算法的运行时间$=\sum$某简单操作的运行时间

- 简单操作的运行时间，由机器的指令性能、速度、编译的代码指令决定，**与算法本身无关**
- 假设每条语句所需的时间均为**单位时间**

**算法的运行时间$\approx$语句频度之和**

### 时间复杂度的计算方式

> 例如：两个$n\times n$的矩阵相乘

```C
for(i=1;i<=n;i++){             // n+1次
  for(j=1;j<=n;j++){           // n*(n+1)次
    c[i][j]=0                  // n*n次
    for(k=0;k<n;k++){          // n*n*(n+1)次
      c[i][j]+=a[i][k]*b[k][j] // n*n*n次
    }
  }
}
```

- 上述时间消耗$T(n)=2n^{3}+3n^{2}+2n+1$

### 时间复杂度与数据集关系

例如：循序查找数组中等于e的元素

```c
for(i=0;i<n;i++)
  if(a[i]==e)return i+1
return 0;
```

- 最好情况：1
- 最坏情况：n
- 平均时间复杂度为：$O(n)$

#### 时间复杂度的情况

- 最坏时间复杂度：在最坏情况下的时间复杂度
- 平均时间复杂度：所有可能的输入实例在等概率出现的情况下的期望运行时间
- 最好时间复杂度：在最好的情况下的时间复杂度

通常只考虑算法的**最坏时间复杂度**和**平均时间复杂度**

### 时间复杂度的比较

$$
O(1)\leq O(\log n)\leq O(n)\leq O(n\log n)\leq O(n^{2})\leq O(n^{3})\leq O(2^{n})\leq(n!)
$$

## 空间复杂度

算法执行过程中所耗费的**存储空间**

- 记作：$S(n)=O(f(n))$
- n： 问题规模/大小


### 算法占据的空间

- 算法本身
  - 输入/输出
  - 指令
  - 常量
  - 变量
- ***辅助空间***

#### 算法占据空间的举例

> 将一维数组a中的n个元素逆序放到原数组中

方式一
```c
for(i=0;i<n/2;i++){
  t=a[i]; 
  a[i]=a[n-i-1];
  a[n-i-1]=t;
}
```
- t 是辅助空间
- $S(n)=O(1)$

方式二

```c
for(i=0;i<n;i++)
  b[i]=a[n-i-1]; 
for(i=0;i<n;i++)
  a[i]=b[i];
```
- b 是辅助空间
- $S(n)=O(n)$


